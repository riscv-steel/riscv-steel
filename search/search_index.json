{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RISC-V Steel Documentation","text":""},{"location":"#h2-homepage-no-top-margin","title":"Welcome to RISC-V Steel DocumentationGet Started","text":"<p>RISC-V Steel is a microcontroller design developed in Verilog that implements the RV32I instruction set of RISC-V. It is designed for easy, seamless integration into embedded systems, systems-on-chip (SoC), and FPGA designs, facilitating the rapid development of innovative RISC-V applications.</p> <p>RISC-V Steel can run real-time operating systems such as FreeRTOS, as well as bare-metal embedded software. Its design includes components such as memory, timers, and interfaces for UART, GPIO, and SPI communication, enabling RISC-V Steel to integrate with a variety of sensors and actuators commonly used in embedded applications.</p> <p>The quickest way to get started is to implement one of the example projects on your FPGA. Check it out:</p> <ul> <li>Hello World Example </li> <li>FreeRTOS Example</li> </ul> <p>See the User Guide to learn how to create your own applications.</p> <p> </p>"},{"location":"hardware/","title":"RISC-V Steel Hardware Docs","text":""},{"location":"hardware/#introduction","title":"Introduction","text":"<p>RISC-V Steel is a microcontroller design developed in Verilog that implements the RV32I instruction set of RISC-V. It is designed for easy, seamless integration into embedded systems, systems-on-chip (SoC), and FPGA designs, facilitating the rapid development of innovative RISC-V applications.</p> <p>RISC-V Steel can run real-time operating systems such as FreeRTOS, as well as bare-metal embedded software. Its design includes components such as memory, timers, and interfaces for UART, GPIO, and SPI communication, enabling RISC-V Steel to integrate with a variety of sensors and actuators commonly used in embedded applications.</p> <p>For information on how to develop new applications with RISC-V Steel, see the User Guide.</p> <p>RISC-V Steel implements the following features of the RISC-V specifications:</p> <ul> <li>the RV32I Base Integer Instruction Set, <code>v2.1</code></li> <li>the Zicsr Extension for Control and Status Register (CSR) Instructions, <code>v2.0</code></li> <li>the Machine-Level ISA, <code>v1.13</code></li> </ul>"},{"location":"hardware/#architecture","title":"Architecture","text":"<p>A top-level view of RISC-V Steel architecture is presented in the diagram below.</p> <p></p> Figure 1. RISC-V Steel Architecture"},{"location":"hardware/#source-files","title":"Source Files","text":"<p>The source files of RISC-V Steel are saved in the <code>hardware/</code> folder of its GitHub repository.</p>"},{"location":"hardware/#configuration","title":"Configuration","text":"<p>The table below lists the configuration parameters of RISC-V Steel Top Module, <code>rvsteel.v</code>:</p> Parameter name and description Value type Default value BOOT_ADDRESSMemory address of the first instruction to be fetched and executed. 32-bit hexadecimal <code>32'h00000000</code> CLOCK_FREQUENCYFrequency (in Hertz) of the <code>clock</code> input signal. Integer <code>50000000</code> UART_BAUD_RATEBaud rate of the UART module (in bauds per second). Integer <code>9600</code> MEMORY_SIZESize of the memory module (in bytes). Integer <code>8192</code> MEMORY_INIT_FILEAbsolute path to the memory initialization file. String <code>(empty string)</code> GPIO_WIDTHNumber of general-purpose I/O pins. Integer <code>1</code> SPI_NUM_CHIP_SELECTNumber of Chip Select (CS) lines for the SPI Controller. Integer <code>1</code>"},{"location":"hardware/#io-signals","title":"I/O Signals","text":"<p>The input/output signals of RISC-V Steel Top Module, <code>rvsteel.v</code>, are listed in the table below:</p> Pin name and description Direction Size clockClock input. Input 1 bit resetReset pin (active-high). Input 1 bit haltHalt pin (active-high). Input 1 bit uart_rxUART receiver pin. Input 1 bit uart_txUART transmitter pin. Output 1 bit gpio_inputGPIO input signals. Input <code>GPIO_WIDTH</code> gpio_oeGPIO output enable. Output <code>GPIO_WIDTH</code> gpio_outputGPIO output signals. Output <code>GPIO_WIDTH</code> sclkSPI Controller clock. Output 1 bit picoSPI Peripheral In Controller Out. Output 1 bit pociSPI Peripheral Out Controller In. Input 1 bit csSPI Chip Select lines. Output <code>SPI_NUM_CHIP_SELECT</code>"},{"location":"hardware/#memory-map","title":"Memory Map","text":"<p>The devices in RISC-V Steel are mapped to memory addresses as detailed below:</p> Start address Final address Range size (Bytes) Device <code>0x00000000</code> <code>0x(MEMORY_SIZE-1)</code> <code>MEMORY_SIZE</code> RAM <code>0x80000000</code> <code>0x8000000f</code> 16 UART Controller <code>0x80010000</code> <code>0x8001001f</code> 32 Timer <code>0x80020000</code> <code>0x8002001f</code> 32 GPIO Controller <code>0x80030000</code> <code>0x8003001f</code> 32 SPI Controller <p> </p>"},{"location":"userguide/","title":"User Guide","text":""},{"location":"userguide/#introduction","title":"Introduction","text":"<p>The process of developing a new application with RISC-V Steel involves two main steps:</p> <ol> <li> <p>Building the application</p> <p>The first step is to write the source code for the new application and build it with the RISC-V GNU Toolchain. The build process generates a <code>.hex</code> file that is later used to initialize the memory of RISC-V Steel.</p> </li> <li> <p>Running on an FPGA</p> <p>Once you have built the application, you can run it on RISC-V Steel. To do this, you need to implement an instance of RISC-V Steel on an FPGA and initialize it with the <code>.hex</code> file generated in the first step.</p> </li> </ol>"},{"location":"userguide/#prerequisites","title":"Prerequisites","text":"<p>To build software for RISC-V you need the RISC-V GNU Toolchain, a suite of compilers and development tools for the RISC-V architecture. </p> <p>Run the commands below to install and configure the RISC-V GNU Toolchain for RISC-V Steel:</p> 1. Clone the RISC-V GNU Toolchain repository<pre><code>git clone https://github.com/riscv-collab/riscv-gnu-toolchain\n</code></pre> UbuntuFedora/CentOS/RHEL/RockyArch LinuxOS X 2. Install dependencies (Ubuntu)<pre><code>sudo apt-get install \\\n    autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev \\\n    libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc \\\n    zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev libslirp-dev\n</code></pre> 2. Install dependencies (Fedora/CentOS/RHEL/Rocky)<pre><code>sudo yum install \\\n    autoconf automake python3 libmpc-devel mpfr-devel gmp-devel gawk  bison flex \\\n    texinfo patchutils gcc gcc-c++ zlib-devel expat-devel libslirp-devel\n</code></pre> 2. Install dependencies (Arch Linux)<pre><code>sudo pacman -Syyu \\\n    autoconf automake curl python3 libmpc mpfr gmp gawk base-devel bison flex texinfo \\\n    gperf libtool patchutils bc zlib expat libslirp\n</code></pre> 2. Install dependencies (OS X)<pre><code>brew install python3 gawk gnu-sed gmp mpfr libmpc isl zlib expat texinfo flock libslirp\n</code></pre> 3. Configure the RISC-V GNU Toolchain for RISC-V Steel<pre><code>cd riscv-gnu-toolchain &amp;&amp; ./configure --with-arch=rv32izicsr --with-abi=ilp32 --prefix=/opt/riscv\n</code></pre> <p>Important: The <code>--prefix</code> option defines the installation folder. You need to set it to a folder where you have <code>rwx</code> permissions. The command above assumes you have <code>rwx</code> permissions on <code>/opt</code>.</p> 4. Compile and install<pre><code>make -j $(nproc)\n</code></pre>"},{"location":"userguide/#building-the-application","title":"Building the application","text":"<p>RISC-V Steel offers two template projects to help you start developing new applications: a bare-metal template and a more sophisticated FreeRTOS template.</p> <p>Both templates include a <code>main.c</code> file where you place the source code for the new application. These projects use CMake to configure the RISC-V GNU Toolchain for RISC-V Steel, which simplifies the process of compiling and linking the software.</p> <p>To start a new application, follow the steps below.</p> 1. Clone RISC-V Steel repository<pre><code>git clone https://github.com/riscv-steel/riscv-steel\n</code></pre> Bare-metalFreeRTOS 2. Copy the template project (Bare-metal)<pre><code>cp -r riscv-steel/templates/baremetal my_project/\n</code></pre> 2. Copy the template project (FreeRTOS)<pre><code>cp -r riscv-steel/templates/freertos my_project/\n</code></pre> <p>Find the <code>main.c</code> file in the project folder and write the code for the new application in this file.</p> Bare-metalFreeRTOS 3. Build the application (Bare-metal)<pre><code>cd my_project/ &amp;&amp; make PREFIX=/opt/riscv\n</code></pre> 3. Build the application (FreeRTOS)<pre><code>cd my_project/ &amp;&amp; make PREFIX=/opt/riscv CLOCK_FREQUENCY=&lt;freq_in_hertz&gt;\n</code></pre> <p>The <code>PREFIX</code> variable must specify the folder where the RISC-V GNU Toolchain is installed. For the FreeRTOS template, you also need to set the <code>CLOCK_FREQUENCY</code> variable to match the clock frequency of the FPGA board where the application will run.</p> <p>A successfull build ends with a message like this:</p> Successful build report<pre><code>Memory init file:   build/freertos.hex\nBinary executable:  build/freertos.elf\nDisassembly:        build/freertos.objdump\n\nMemory usage report (MEMORY_SIZE = 32K)\n      text       data        bss      total filename\n     14092        304       9196      23592 freertos.elf\n</code></pre> <p>The <code>.hex</code> file generated by the build process will be used in the next step to initialize the memory of RISC-V Steel.</p>"},{"location":"userguide/#running-on-an-fpga","title":"Running on an FPGA","text":"<p>Once you have generated the <code>.hex</code> file you can implement RISC-V Steel on an FPGA to run the application. This process consists of two steps:</p> <ul> <li> <p>First, create a wrapper module that includes an instance of RISC-V Steel, configure it for the target FPGA, and initialize it with the application to be run using the <code>.hex</code> file.</p> </li> <li> <p>Next, use the EDA software provided by your FPGA vendor to synthesize the wrapper module and program the FPGA with it.</p> </li> </ul> 1. Creating the wrapper module <p>Using your preferred text editor, create a Verilog file called <code>rvsteel_wrapper.v</code> and add the code provided below. Make sure to modify the file according to the instructions in the comments.</p> rvsteel_wrapper.v<pre><code>module rvsteel_wrapper (\n\n  input   wire          clock       ,\n  input   wire          reset       ,\n  input   wire          halt        ,\n\n  // UART pins\n  // You can remove them if your application does not use the UART controller\n  input   wire          uart_rx     ,\n  output  wire          uart_tx     ,\n\n  // General Purpose I/O pins\n  // You can remove them if your application does not use the GPIO controller\n  input   wire  [3:0]   gpio_input  ,\n  output  wire  [3:0]   gpio_oe     ,\n  output  wire  [3:0]   gpio_output ,\n\n  // Serial Peripheral Interface (SPI) pins\n  // You can remove them if your application does not use the SPI controller\n  output  wire          sclk        ,\n  output  wire          pico        ,\n  input   wire          poci        ,\n  output  wire  [0:0]   cs\n\n  );\n\n  reg reset_debounced;\n  always @(posedge clock) reset_debounced &lt;= reset;\n\n  reg halt_debounced;\n  always @(posedge clock) halt_debounced &lt;= halt;\n\n  rvsteel #(\n\n    // Frequency (in Hertz) of the `clock` pin\n    .CLOCK_FREQUENCY          (50000000                   ),\n\n    // Absolute path to the .hex file generated by the build\n    .MEMORY_INIT_FILE         (\"/path/to/myapp.hex\"       ),    \n\n    // The size you want for the memory (in bytes)\n    .MEMORY_SIZE              (8192                       ),\n\n    // The UART baud rate (in bauds per second)\n    .UART_BAUD_RATE           (9600                       ),\n\n    // Don't change it unless you explicitly modified the boot address\n    .BOOT_ADDRESS             (32'h00000000               ),\n\n    // Width of the gpio_* ports\n    .GPIO_WIDTH               (4                          ),\n\n    // Width of the cs port\n    .SPI_NUM_CHIP_SELECT      (1                          ))\n\n    rvsteel_instance (\n\n    .clock                    (clock                      ),\n    .reset                    (reset_debounced            ),\n    .halt                     (halt_debounced             ),\n    .uart_rx                  (uart_rx                    ),\n    .uart_tx                  (uart_tx                    ),\n    .gpio_input               (gpio_input                 ),\n    .gpio_oe                  (gpio_oe                    ),\n    .gpio_output              (gpio_output                ),\n    .sclk                     (sclk                       ),\n    .pico                     (pico                       ),\n    .poci                     (poci                       ),\n    .cs                       (cs                         ));\n\nendmodule\n</code></pre> 2. Synthesizing rvsteel_wrapper.v <p>The steps to synthesize a Verilog module can differ based on the FPGA model and vendor, but they generally follow this sequence:</p> <ol> <li> <p>Start a new project: Open the EDA tool provided by your FPGA vendor (e.g., AMD Vivado, Intel Quartus, Lattice iCEcube).</p> </li> <li> <p>Add files to the project: Include <code>rvsteel_wrapper.v</code> to the project and all files in the <code>hardware/</code> folder of RISC-V Steel repository.</p> </li> <li> <p>Create a design constraints file: Map the ports of <code>rvsteel_wrapper.v</code> to the corresponding devices on the FPGA board.</p> </li> <li> <p>Run the synthesis process: This includes placing and routing, as well as any other necessary steps to generate a bitstream for the FPGA.</p> </li> <li> <p>Generate the bitstream: Once completed, program the FPGA with the generated bitstream.</p> </li> </ol> <p>The application will start running immediately after you program the FPGA!</p> <p> </p>"},{"location":"examples/freertos/","title":"FreeRTOS Example","text":""},{"location":"examples/freertos/#introduction","title":"Introduction","text":"<p>The FreeRTOS example is a more sophisticated application that runs on top of FreeRTOS, an open-source real-time operating system. The application uses the GPIO controller of RISC-V Steel to make 2 LEDs blink in a specific pattern with the help of FreeRTOS task scheduler.</p>"},{"location":"examples/freertos/#prerequisites","title":"Prerequisites","text":"<p>To run this example you need an FPGA board with at least 2 LEDs and 32KB of Block RAM.</p> <p>Additionally, you need to have the RISC-V GNU Toolchain installed on your machine to build the example. You can find instructions on how to install the RISC-V GNU Toolchain in the User Guide.</p>"},{"location":"examples/freertos/#building-the-example","title":"Building the example","text":"<p>Run the commands below to build the FreeRTOS example:</p> 1. Clone RISC-V Steel repository<pre><code>git clone https://github.com/riscv-steel/riscv-steel\n</code></pre> 2. Build the software for the FreeRTOS example<pre><code>cd riscv-steel/examples/freertos/software\nmake PREFIX=/opt/riscv CLOCK_FREQUENCY=&lt;freq_in_hertz&gt;\n</code></pre> <p>The <code>PREFIX</code> variable must specify the folder where the RISC-V GNU Toolchain is installed. You also need to set the <code>CLOCK_FREQUENCY</code> variable to match the clock frequency of the FPGA board where the application will run.</p> <p>A successfull build ends with a message like this:</p> Successful build report<pre><code>Memory init file:   build/freertos.hex\nBinary executable:  build/freertos.elf\nDisassembly:        build/freertos.objdump\n\nMemory usage report (MEMORY_SIZE = 32K)\n      text       data        bss      total filename\n     14092        304       9196      23592 freertos.elf\n</code></pre> <p>The <code>freertos.hex</code> file generated by the build process will be used in the next step to initialize the memory of RISC-V Steel.</p>"},{"location":"examples/freertos/#implementing-on-an-fpga","title":"Implementing on an FPGA","text":"Creating the FreeRTOS module <p>Using your preferred text editor, create a Verilog file name <code>freertos.v</code> and add the source code below. Make sure to modify <code>freertos.v</code> as follows:</p> <ul> <li>Change the <code>MEMORY_INIT_FILE</code> parameter to the absolute path of the <code>freertos.hex</code> file you generated in the previous step.</li> <li>Change the <code>CLOCK_FREQUENCY</code> parameter to the frequency (in Hertz) of the <code>clock</code> input.</li> </ul> freertos.v<pre><code>module freertos #(\n\n  parameter GPIO_WIDTH = 2\n\n  )(\n\n  input   wire clock,\n  input   wire reset,\n  output  wire [GPIO_WIDTH-1:0] gpio\n\n  );\n\n  // Reset button debouncing\n  reg reset_debounced;\n  always @(posedge clock) begin\n    reset_debounced &lt;= reset;\n  end\n\n  rvsteel #(\n\n  // Please adjust these parameters accordingly\n  .CLOCK_FREQUENCY          (50000000                   ),\n  .MEMORY_SIZE              (32768                      ),\n  .MEMORY_INIT_FILE         (\"/path/to/freertos.hex\"    ),\n  .GPIO_WIDTH               (GPIO_WIDTH                 )\n\n  ) rvsteel_instance (\n\n  .clock                    (clock                      ),\n  .reset                    (reset_debounced            ),\n  .gpio_output              (gpio                       ),\n\n  // Unused inputs need to be hardwired to zero\n  .halt                     (1'b0                       ),\n  .uart_rx                  (1'b0                       ),\n  .gpio_input               ({GPIO_WIDTH{1'b0}}         ),\n  .poci                     (1'b0                       ),\n\n  // Unused outputs can be left open\n  .uart_tx                  (                           ),  \n  .gpio_oe                  (                           ),\n  .sclk                     (                           ),\n  .pico                     (                           ),  \n  .cs                       (                           ));\n\nendmodule\n</code></pre> Synthesizing the FreeRTOS module <p>To implement the <code>freertos.v</code> module on your FPGA, follow the steps below:</p> <ol> <li> <p>Open the EDA tool provided by your FPGA vendor (e.g., AMD Vivado, Intel Quartus, Lattice iCEcube).</p> </li> <li> <p>Include <code>freertos.v</code> to the project and all files in the <code>hardware/</code> folder of RISC-V Steel repository.</p> </li> <li> <p>Create a design constraints file and map the ports of <code>freertos.v</code> to the corresponding devices on the FPGA board.</p> <ul> <li>Map the <code>gpio</code> outputs to 2 LEDs</li> <li>Map the <code>reset</code> input to a push-button or switch</li> <li>Map the <code>clock</code> input to the clock source</li> </ul> </li> <li> <p>Run the synthesis process.</p> </li> <li> <p>Generate the bitstream and, once completed, program the FPGA with it.</p> </li> </ol> <p>The LEDs should start blinking once you've finished programming the FPGA!</p>"},{"location":"examples/freertos/#featured-boards","title":"Featured boards","text":"<p>We provide project files for some featured FPGA boards. If you have one of the boards listed below, please follow the specific steps for your board:</p>"},{"location":"examples/freertos/#arty-a7","title":"Arty A7","text":"<ul> <li> <p>Build the FreeRTOS application as instructed in Building the example</p> <p>Use <code>CLOCK_FREQUENCY=50000000</code>.</p> </li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/freertos/boards/arty_a7/create_project_arty_a7_&lt;variant&gt;.tcl</code>, where <code>&lt;variant&gt;</code> is the variant of your board (either 35T or 100T).</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>The LEDs should start blinking once you've finished programming the FPGA!</li> </ul>"},{"location":"examples/freertos/#cmod-a7","title":"Cmod A7","text":"<ul> <li> <p>Build the FreeRTOS application as instructed in Building the example</p> <p>Use <code>CLOCK_FREQUENCY=12000000</code>.</p> </li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/freertos/boards/cmod_a7/create_project_cmod_a7.tcl</code>.</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>The LEDs should start blinking once you've finished programming the FPGA!</li> </ul> <p> </p>"},{"location":"examples/helloworld/","title":"Hello World Example","text":""},{"location":"examples/helloworld/#introduction","title":"Introduction","text":"<p>The Hello World example is a bare-metal application that uses the UART controller of RISC-V Steel to send a Hello World message to a host computer.</p>"},{"location":"examples/helloworld/#prerequisites","title":"Prerequisites","text":"<p>To run this example, you need an FPGA board that has a UART-USB bridge, a common feature on most FPGAs.</p> <p>Additionally, you need to have the RISC-V GNU Toolchain installed on your machine to build the example. You can find instructions on how to install the RISC-V GNU Toolchain in the User Guide.</p>"},{"location":"examples/helloworld/#building-the-example","title":"Building the example","text":"<p>Run the commands below to build the Hello World example:</p> 1. Clone RISC-V Steel repository<pre><code>git clone https://github.com/riscv-steel/riscv-steel\n</code></pre> 2. Build the software for the Hello World example<pre><code>cd riscv-steel/examples/hello_world/software &amp;&amp; make PREFIX=/opt/riscv\n</code></pre> <p>The <code>PREFIX</code> variable must specify the folder where the RISC-V GNU Toolchain is installed.</p> <p>A successfull build ends with a message like this:</p> Successful build report<pre><code>Memory init file:   build/hello_world.hex\nBinary executable:  build/hello_world.elf\nDisassembly:        build/hello_world.objdump\n\nMemory usage report (MEMORY_SIZE = 8K)\n      text       data        bss      total filename\n       240          0          0        240 hello_world.elf\n</code></pre> <p>The <code>hello_world.hex</code> file generated by the build process will be used in the next step to initialize the memory of RISC-V Steel.</p>"},{"location":"examples/helloworld/#implementing-on-an-fpga","title":"Implementing on an FPGA","text":"Creating the Hello World module <p>Using your preferred text editor, create a Verilog file name <code>hello_world.v</code> and add the source code below. Make sure to modify <code>hello_world.v</code> as follows:</p> <ul> <li>Change the <code>MEMORY_INIT_FILE</code> parameter to the absolute path of the <code>hello_world.hex</code> file you generated in the previous step.</li> <li>Change the <code>CLOCK_FREQUENCY</code> parameter to the frequency (in Hertz) of the <code>clock</code> input.</li> </ul> hello_world.v<pre><code>module hello_world (\n\n  input   wire clock,\n  input   wire reset,\n  output  wire uart_tx\n\n  );\n\n  // Reset button debouncing\n  reg reset_debounced;\n  always @(posedge clock) begin\n    reset_debounced &lt;= reset;\n  end\n\n  rvsteel #(\n\n  // Please adjust these two parameters accordingly\n  .CLOCK_FREQUENCY          (50000000                   ),\n  .MEMORY_INIT_FILE         (\"/path/to/hello_world.hex\" )\n\n  ) rvsteel_instance (\n\n  .clock                    (clock                      ),\n  .reset                    (reset_debounced            ),\n  .uart_tx                  (uart_tx                    ),\n\n  // Unused inputs need to be hardwired to zero\n  .halt                     (1'b0                       ),\n  .uart_rx                  (1'b0                       ),\n  .gpio_input               (1'b0                       ),\n  .poci                     (1'b0                       ),\n\n  // Unused outputs can be left open  \n  .gpio_oe                  (                           ),\n  .gpio_output              (                           ),\n  .sclk                     (                           ),\n  .pico                     (                           ),  \n  .cs                       (                           ));\n\nendmodule\n</code></pre> Synthesizing the Hello World module <p>To implement the <code>hello_world.v</code> module on your FPGA, follow the steps below:</p> <ol> <li> <p>Open the EDA tool provided by your FPGA vendor (e.g., AMD Vivado, Intel Quartus, Lattice iCEcube).</p> </li> <li> <p>Include <code>hello_world.v</code> to the project and all files in the <code>hardware/</code> folder of RISC-V Steel repository.</p> </li> <li> <p>Create a design constraints file and map the ports of <code>hello_world.v</code> to the corresponding devices on the FPGA board.</p> <ul> <li>Map the <code>uart_tx</code> output to the UART-USB bridge</li> <li>Map the <code>reset</code> input to a push-button or switch</li> <li>Map the <code>clock</code> input to the clock source</li> </ul> </li> <li> <p>Run the synthesis process.</p> </li> <li> <p>Generate the bitstream and, once completed, program the FPGA with it.</p> </li> </ol>"},{"location":"examples/helloworld/#running-the-application","title":"Running the application","text":"<p>Now that the FPGA is programmed, you can see the Hello World message on a host computer with the help of a serial terminal emulator like PySerial:</p> <ul> <li>Connect the FPGA board to your computer</li> <li> <p>Install PySerial (or other serial terminal emulator):</p> <pre><code>python3 -m pip install pyserial\n</code></pre> </li> <li> <p>Open a serial terminal</p> <p>With PySerial, a serial terminal can be opened by running:</p> <pre><code>python3 -m serial.tools.miniterm\n</code></pre> <p>PySerial will show the available serial ports, one of which is the UART-USB bridge of the FPGA board. Choose it to connect.</p> </li> <li> <p>Finally, press the reset button.</p> </li> </ul> <p>You should now see the Hello World message!</p>"},{"location":"examples/helloworld/#featured-boards","title":"Featured boards","text":"<p>We provide project files for some featured FPGA boards. If you have one of the boards listed below, please follow the specific steps for your board:</p>"},{"location":"examples/helloworld/#arty-a7","title":"Arty A7","text":"<ul> <li>Build the Hello World application as instructed in Building the example</li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/hello_world/boards/arty_a7/create_project_arty_a7_&lt;variant&gt;.tcl</code>, where <code>&lt;variant&gt;</code> is the variant of your board (either 35T or 100T).</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>Run the example as instructed in Running the application</li> </ul>"},{"location":"examples/helloworld/#cmod-a7","title":"Cmod A7","text":"<ul> <li>Build the Hello World application as instructed in Building the example</li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/hello_world/boards/cmod_a7/create_project_cmod_a7.tcl</code>.</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>Run the example as instructed in Running the application</li> </ul> <p> </p>"}]}